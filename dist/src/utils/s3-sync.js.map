{
  "version": 3,
  "sources": ["../../../src/utils/s3-sync.ts"],
  "sourcesContent": ["import {\n    DeleteObjectsOutput,\n    DeleteObjectsRequest,\n    ListObjectsV2Output,\n    ListObjectsV2Request,\n    PutObjectOutput,\n    PutObjectRequest,\n    Object as S3Object,\n} from \"aws-sdk/clients/s3\";\nimport * as fs from \"fs\";\nimport * as util from \"util\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { lookup } from \"mime-types\";\nimport { chunk } from \"lodash\";\nimport chalk from \"chalk\";\nimport AwsProvider from \"../classes/AwsProvider\";\n\nconst readdir = util.promisify(fs.readdir);\nconst stat = util.promisify(fs.stat);\n\ntype S3Objects = Record<string, S3Object>;\n\n/**\n * Synchronize a local folder to a S3 bucket.\n *\n * @return True if some changes were uploaded.\n */\nexport async function s3Sync({\n    aws,\n    localPath,\n    bucketName,\n}: {\n    aws: AwsProvider;\n    localPath: string;\n    bucketName: string;\n}): Promise<{ hasChanges: boolean }> {\n    let hasChanges = false;\n    const filesToUpload: string[] = await listFilesRecursively(localPath);\n    const existingS3Objects = await s3ListAll(aws, bucketName);\n\n    // Upload files by chunks\n    let skippedFiles = 0;\n    for (const batch of chunk(filesToUpload, 2)) {\n        await Promise.all(\n            batch.map(async (file) => {\n                const fileContent = fs.readFileSync(path.join(localPath, file));\n\n                // Check that the file isn't already uploaded\n                if (file in existingS3Objects) {\n                    const existingObject = existingS3Objects[file];\n                    const etag = computeS3ETag(fileContent);\n                    if (etag === existingObject.ETag) {\n                        skippedFiles++;\n\n                        return;\n                    }\n                }\n\n                console.log(`Uploading ${file}`);\n                await s3Put(aws, bucketName, file, fileContent);\n                hasChanges = true;\n            })\n        );\n    }\n    if (skippedFiles > 0) {\n        console.log(chalk.gray(`Skipped uploading ${skippedFiles} unchanged files`));\n    }\n\n    const objectsToDelete = findObjectsToDelete(Object.keys(existingS3Objects), filesToUpload);\n    if (objectsToDelete.length > 0) {\n        objectsToDelete.map((key) => console.log(`Deleting ${key}`));\n        await s3Delete(aws, bucketName, objectsToDelete);\n        hasChanges = true;\n    }\n\n    return { hasChanges };\n}\n\nasync function listFilesRecursively(directory: string): Promise<string[]> {\n    const items = await readdir(directory);\n\n    const files = await Promise.all(\n        items.map(async (fileName) => {\n            const fullPath = path.join(directory, fileName);\n            const fileStat = await stat(fullPath);\n            if (fileStat.isFile()) {\n                return [fileName];\n            } else if (fileStat.isDirectory()) {\n                const subFiles = await listFilesRecursively(fullPath);\n\n                return subFiles.map((subFileName) => path.join(fileName, subFileName));\n            }\n\n            return [];\n        })\n    );\n\n    return files.flat(1);\n}\n\nasync function s3ListAll(aws: AwsProvider, bucketName: string): Promise<S3Objects> {\n    let result;\n    let continuationToken = undefined;\n    const objects: Record<string, S3Object> = {};\n    do {\n        result = await aws.request<ListObjectsV2Request, ListObjectsV2Output>(\"S3\", \"listObjectsV2\", {\n            Bucket: bucketName,\n            MaxKeys: 1000,\n            ContinuationToken: continuationToken,\n        });\n        (result.Contents ?? []).forEach((object) => {\n            if (object.Key === undefined) {\n                return;\n            }\n            objects[object.Key] = object;\n        });\n        continuationToken = result.NextContinuationToken;\n    } while (result.IsTruncated === true);\n\n    return objects;\n}\n\nfunction findObjectsToDelete(existing: string[], target: string[]): string[] {\n    // Returns every key that shouldn't exist anymore\n    return existing.filter((key) => target.indexOf(key) === -1);\n}\n\nasync function s3Put(aws: AwsProvider, bucket: string, key: string, fileContent: Buffer): Promise<void> {\n    let contentType = lookup(key);\n    if (contentType === false) {\n        contentType = \"application/octet-stream\";\n    }\n    await aws.request<PutObjectRequest, PutObjectOutput>(\"S3\", \"putObject\", {\n        Bucket: bucket,\n        Key: key,\n        Body: fileContent,\n        ContentType: contentType,\n    });\n}\n\nasync function s3Delete(aws: AwsProvider, bucket: string, keys: string[]): Promise<void> {\n    await aws.request<DeleteObjectsRequest, DeleteObjectsOutput>(\"S3\", \"deleteObjects\", {\n        Bucket: bucket,\n        Delete: {\n            Objects: keys.map((key) => {\n                return {\n                    Key: key,\n                };\n            }),\n        },\n    });\n}\n\nexport function computeS3ETag(fileContent: Buffer): string {\n    return `\"${crypto.createHash(\"md5\").update(fileContent).digest(\"hex\")}\"`;\n}\n"],
  "mappings": "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",
  "names": []
}
