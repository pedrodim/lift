{
  "version": 3,
  "sources": ["../../../src/constructs/StaticWebsite.ts"],
  "sourcesContent": ["import { Bucket } from \"@aws-cdk/aws-s3\";\nimport {\n    AllowedMethods,\n    CachePolicy,\n    Distribution,\n    FunctionEventType,\n    HttpVersion,\n    OriginAccessIdentity,\n    ViewerProtocolPolicy,\n} from \"@aws-cdk/aws-cloudfront\";\nimport * as cloudfront from \"@aws-cdk/aws-cloudfront\";\nimport { Construct as CdkConstruct, CfnOutput, Duration, RemovalPolicy } from \"@aws-cdk/core\";\nimport { FromSchema } from \"json-schema-to-ts\";\nimport {\n    DeleteObjectsOutput,\n    DeleteObjectsRequest,\n    ListObjectsV2Output,\n    ListObjectsV2Request,\n} from \"aws-sdk/clients/s3\";\nimport chalk from \"chalk\";\nimport { CreateInvalidationRequest, CreateInvalidationResult } from \"aws-sdk/clients/cloudfront\";\nimport { S3Origin } from \"@aws-cdk/aws-cloudfront-origins\";\nimport * as acm from \"@aws-cdk/aws-certificatemanager\";\nimport { log } from \"../utils/logger\";\nimport { s3Sync } from \"../utils/s3-sync\";\nimport AwsProvider from \"../classes/AwsProvider\";\nimport Construct from \"../classes/Construct\";\n\nexport const STATIC_WEBSITE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        type: { const: \"static-website\" },\n        path: { type: \"string\" },\n        domain: {\n            anyOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                },\n            ],\n        },\n        certificate: { type: \"string\" },\n        security: {\n            type: \"object\",\n            properties: {\n                allowIframe: { type: \"boolean\" },\n            },\n            additionalProperties: false,\n        },\n    },\n    additionalProperties: false,\n    required: [\"path\"],\n} as const;\n\ntype Configuration = FromSchema<typeof STATIC_WEBSITE_DEFINITION>;\n\nexport class StaticWebsite extends CdkConstruct implements Construct {\n    private readonly bucketNameOutput: CfnOutput;\n    private readonly domainOutput: CfnOutput;\n    private readonly cnameOutput: CfnOutput;\n    private readonly distributionIdOutput: CfnOutput;\n\n    constructor(\n        scope: CdkConstruct,\n        private readonly id: string,\n        readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        if (configuration.domain !== undefined && configuration.certificate === undefined) {\n            throw new Error(\n                `Invalid configuration for the static website ${id}: if a domain is configured, then a certificate ARN must be configured as well.`\n            );\n        }\n\n        const bucket = new Bucket(this, \"Bucket\", {\n            // For a static website, the content is code that should be versioned elsewhere\n            removalPolicy: RemovalPolicy.DESTROY,\n        });\n\n        const cloudFrontOAI = new OriginAccessIdentity(this, \"OriginAccessIdentity\", {\n            comment: `Identity that represents CloudFront for the ${id} static website.`,\n        });\n        bucket.grantRead(cloudFrontOAI);\n\n        // Cast the domains to an array\n        const domains = configuration.domain !== undefined ? [configuration.domain].flat() : undefined;\n        const certificate =\n            configuration.certificate !== undefined\n                ? acm.Certificate.fromCertificateArn(this, \"Certificate\", configuration.certificate)\n                : undefined;\n        const distribution = new Distribution(this, \"CDN\", {\n            comment: `${provider.stackName} ${id} website CDN`,\n            // Send all page requests to index.html\n            defaultRootObject: \"index.html\",\n            defaultBehavior: {\n                // Origins are where CloudFront fetches content\n                origin: new S3Origin(bucket, {\n                    originAccessIdentity: cloudFrontOAI,\n                }),\n                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,\n                // Use the \"Managed-CachingOptimized\" policy\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list\n                cachePolicy: CachePolicy.CACHING_OPTIMIZED,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n                functionAssociations: [\n                    {\n                        function: this.createResponseFunction(),\n                        eventType: FunctionEventType.VIEWER_RESPONSE,\n                    },\n                ],\n            },\n            // For SPA we need dynamic pages to be served by index.html\n            errorResponses: [\n                {\n                    httpStatus: 404,\n                    ttl: Duration.seconds(0),\n                    responseHttpStatus: 200,\n                    responsePagePath: \"/index.html\",\n                },\n            ],\n            // Enable http2 transfer for better performances\n            httpVersion: HttpVersion.HTTP2,\n            certificate: certificate,\n            domainNames: domains,\n        });\n\n        // CloudFormation outputs\n        this.bucketNameOutput = new CfnOutput(this, \"BucketName\", {\n            description: \"Name of the bucket that stores the static website.\",\n            value: bucket.bucketName,\n        });\n        let websiteDomain: string = distribution.distributionDomainName;\n        if (configuration.domain !== undefined) {\n            // In case of multiple domains, we take the first one\n            websiteDomain = typeof configuration.domain === \"string\" ? configuration.domain : configuration.domain[0];\n        }\n        this.domainOutput = new CfnOutput(this, \"Domain\", {\n            description: \"Website domain name.\",\n            value: websiteDomain,\n        });\n        this.cnameOutput = new CfnOutput(this, \"CloudFrontCName\", {\n            description: \"CloudFront CNAME.\",\n            value: distribution.distributionDomainName,\n        });\n        this.distributionIdOutput = new CfnOutput(this, \"DistributionId\", {\n            description: \"ID of the CloudFront distribution.\",\n            value: distribution.distributionId,\n        });\n    }\n\n    commands(): Record<string, () => Promise<void>> {\n        return {\n            upload: this.uploadWebsite.bind(this),\n        };\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            url: () => this.getUrl(),\n            cname: () => this.getCName(),\n        };\n    }\n\n    references(): Record<string, Record<string, unknown>> {\n        return {};\n    }\n\n    async postDeploy(): Promise<void> {\n        await this.uploadWebsite();\n    }\n\n    async uploadWebsite(): Promise<void> {\n        log(`Deploying the static website '${this.id}'`);\n\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            throw new Error(\n                `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`\n            );\n        }\n\n        log(`Uploading directory '${this.configuration.path}' to bucket '${bucketName}'`);\n        const { hasChanges } = await s3Sync({\n            aws: this.provider,\n            localPath: this.configuration.path,\n            bucketName,\n        });\n        if (hasChanges) {\n            await this.clearCDNCache();\n        }\n\n        const domain = await this.getDomain();\n        if (domain !== undefined) {\n            log(`Deployed ${chalk.green(`https://${domain}`)}`);\n        }\n    }\n\n    private async clearCDNCache(): Promise<void> {\n        const distributionId = await this.getDistributionId();\n        if (distributionId === undefined) {\n            return;\n        }\n        await this.provider.request<CreateInvalidationRequest, CreateInvalidationResult>(\n            \"CloudFront\",\n            \"createInvalidation\",\n            {\n                DistributionId: distributionId,\n                InvalidationBatch: {\n                    // This should be a unique ID: we use a timestamp\n                    CallerReference: Date.now().toString(),\n                    Paths: {\n                        // Invalidate everything\n                        Items: [\"/*\"],\n                        Quantity: 1,\n                    },\n                },\n            }\n        );\n    }\n\n    async preRemove(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            // No bucket found => nothing to delete!\n            return;\n        }\n\n        log(\n            `Emptying S3 bucket '${bucketName}' for the '${this.id}' static website, else CloudFormation will fail (it cannot delete a non-empty bucket)`\n        );\n        const data = await this.provider.request<ListObjectsV2Request, ListObjectsV2Output>(\"S3\", \"listObjectsV2\", {\n            Bucket: bucketName,\n        });\n        if (data.Contents === undefined) {\n            return;\n        }\n        const keys = data.Contents.map((item) => item.Key).filter((key): key is string => key !== undefined);\n        await this.provider.request<DeleteObjectsRequest, DeleteObjectsOutput>(\"S3\", \"deleteObjects\", {\n            Bucket: bucketName,\n            Delete: {\n                Objects: keys.map((key) => ({ Key: key })),\n            },\n        });\n    }\n\n    async getUrl(): Promise<string | undefined> {\n        const domain = await this.getDomain();\n        if (domain === undefined) {\n            return undefined;\n        }\n\n        return `https://${domain}`;\n    }\n\n    async getBucketName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.bucketNameOutput);\n    }\n\n    async getDomain(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.domainOutput);\n    }\n\n    async getCName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.cnameOutput);\n    }\n\n    async getDistributionId(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.distributionIdOutput);\n    }\n\n    private createResponseFunction(): cloudfront.Function {\n        const securityHeaders: Record<string, { value: string }> = {\n            \"x-frame-options\": { value: \"SAMEORIGIN\" },\n            \"x-content-type-options\": { value: \"nosniff\" },\n            \"x-xss-protection\": { value: \"1; mode=block\" },\n            \"strict-transport-security\": { value: \"max-age=63072000\" },\n        };\n        if (this.configuration.security?.allowIframe === true) {\n            delete securityHeaders[\"x-frame-options\"];\n        }\n        const jsonHeaders = JSON.stringify(securityHeaders, undefined, 4);\n        /**\n         * CloudFront function that manipulates the HTTP responses to add security headers.\n         */\n        const code = `function handler(event) {\n    var response = event.response;\n    response.headers = Object.assign({}, ${jsonHeaders}, response.headers);\n    return response;\n}`;\n\n        return new cloudfront.Function(this, \"ResponseFunction\", {\n            functionName: `${this.provider.stackName}-${this.provider.region}-${this.id}-response`,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
