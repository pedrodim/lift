{
  "version": 3,
  "sources": ["../../src/plugin.ts"],
  "sourcesContent": ["import { App, Stack } from \"@aws-cdk/core\";\nimport { get, has, merge } from \"lodash\";\nimport chalk from \"chalk\";\nimport { AwsIamPolicyStatements } from \"@serverless/typescript\";\nimport * as path from \"path\";\nimport { readFileSync } from \"fs\";\nimport { dump } from \"js-yaml\";\nimport { FromSchema } from \"json-schema-to-ts\";\nimport type {\n    CloudformationTemplate,\n    CommandsDefinition,\n    Hook,\n    Serverless,\n    VariableResolver,\n} from \"./types/serverless\";\nimport Construct from \"./classes/Construct\";\nimport AwsProvider from \"./classes/AwsProvider\";\nimport { constructs } from \"./constructs\";\nimport { log } from \"./utils/logger\";\n\nconst CONSTRUCTS_DEFINITION = {\n    type: \"object\",\n    patternProperties: {\n        \"^[a-zA-Z0-9-_]+$\": {\n            allOf: [\n                {\n                    // Replacing with a map on constructs values generates type (A | B | C)[] instead of A, B, C\n                    anyOf: [\n                        constructs.storage.schema,\n                        constructs[\"static-website\"].schema,\n                        constructs.webhook.schema,\n                        constructs.queue.schema,\n                    ],\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        type: { type: \"string\" },\n                    },\n                    required: [\"type\"],\n                },\n            ],\n        },\n    },\n    additionalProperties: false,\n} as const;\n\n/**\n * Serverless plugin\n */\nclass LiftPlugin {\n    private readonly constructs: Record<string, Construct> = {};\n    private readonly serverless: Serverless;\n    private readonly app: App;\n    // Only public to be used in tests\n    public readonly stack: Stack;\n    public readonly hooks: Record<string, Hook>;\n    public readonly commands: CommandsDefinition = {};\n    public readonly configurationVariablesSources: Record<string, VariableResolver> = {};\n\n    constructor(serverless: Serverless) {\n        this.app = new App();\n        this.stack = new Stack(this.app);\n        serverless.stack = this.stack;\n\n        this.serverless = serverless;\n\n        this.commands.lift = {\n            commands: {\n                eject: {\n                    lifecycleEvents: [\"eject\"],\n                },\n            },\n        };\n\n        this.hooks = {\n            initialize: this.initialize.bind(this),\n            \"before:aws:info:displayStackOutputs\": this.info.bind(this),\n            \"after:package:compileEvents\": this.appendCloudformationResources.bind(this),\n            \"after:deploy:deploy\": this.postDeploy.bind(this),\n            \"before:remove:remove\": this.preRemove.bind(this),\n            \"lift:eject:eject\": this.eject.bind(this),\n        };\n\n        // TODO variables should be resolved just before deploying each provider\n        // else we might get outdated values\n        this.configurationVariablesSources = {\n            // TODO these 2 variable sources should be merged eventually\n            construct: {\n                resolve: this.resolveReference.bind(this),\n            },\n        };\n\n        this.registerConfigSchema();\n    }\n\n    private initialize() {\n        this.loadConstructs();\n        this.registerCommands();\n        this.appendPermissions();\n    }\n\n    private registerConfigSchema() {\n        this.serverless.configSchemaHandler.defineTopLevelProperty(\"constructs\", CONSTRUCTS_DEFINITION);\n    }\n\n    private loadConstructs() {\n        const awsProvider = new AwsProvider(this.serverless, this.stack);\n        const constructsInputConfiguration = get(this.serverless.configurationInput, \"constructs\", {}) as FromSchema<\n            typeof CONSTRUCTS_DEFINITION\n        >;\n        for (const [id, configuration] of Object.entries(constructsInputConfiguration)) {\n            const constructConstructor = constructs[configuration.type].class;\n            // Typescript cannot infer configuration specific to a type, thus computing intersetion of all configurations to never\n            this.constructs[id] = new constructConstructor(awsProvider.stack, id, configuration as never, awsProvider);\n        }\n    }\n\n    resolveReference({ address }: { address: string }): { value: Record<string, unknown> } {\n        const [id, property] = address.split(\".\", 2);\n        if (!has(this.constructs, id)) {\n            throw new Error(\n                `No construct named '${id}' was found, the \\${construct:${id}.${property}} variable is invalid.`\n            );\n        }\n        const construct = this.constructs[id];\n\n        const properties = construct.references();\n        if (!has(properties, property)) {\n            throw new Error(\n                `\\${construct:${id}.${property}} does not exist. Properties available on \\${construct:${id}} are: ${Object.keys(\n                    properties\n                ).join(\", \")}.`\n            );\n        }\n\n        return {\n            value: properties[property],\n        };\n    }\n\n    async info(): Promise<void> {\n        for (const [id, construct] of Object.entries(this.constructs)) {\n            const outputs = construct.outputs();\n            if (Object.keys(outputs).length > 0) {\n                console.log(chalk.yellow(`${id}:`));\n                for (const [name, resolver] of Object.entries(outputs)) {\n                    const output = await resolver();\n                    if (output !== undefined) {\n                        console.log(`  ${name}: ${output}`);\n                    }\n                }\n            }\n        }\n    }\n\n    private registerCommands() {\n        for (const [id, construct] of Object.entries(this.constructs)) {\n            const commands = construct.commands();\n            for (const [command, handler] of Object.entries(commands)) {\n                this.commands[`${id}:${command}`] = {\n                    lifecycleEvents: [command],\n                };\n                this.hooks[`${id}:${command}:${command}`] = handler;\n            }\n        }\n    }\n\n    private async postDeploy(): Promise<void> {\n        for (const [, construct] of Object.entries(this.constructs)) {\n            if (construct.postDeploy !== undefined) {\n                await construct.postDeploy();\n            }\n        }\n    }\n\n    private async preRemove(): Promise<void> {\n        for (const [, construct] of Object.entries(this.constructs)) {\n            if (construct.preRemove !== undefined) {\n                await construct.preRemove();\n            }\n        }\n    }\n\n    private appendCloudformationResources() {\n        merge(this.serverless.service, {\n            resources: this.app.synth().getStackByName(this.stack.stackName).template as CloudformationTemplate,\n        });\n    }\n\n    private appendPermissions(): void {\n        const statements = Object.entries(this.constructs)\n            .map(([, construct]) => {\n                return ((construct.permissions ? construct.permissions() : []) as unknown) as AwsIamPolicyStatements;\n            })\n            .flat(1);\n        if (statements.length === 0) {\n            return;\n        }\n        this.serverless.service.provider.iamRoleStatements = this.serverless.service.provider.iamRoleStatements ?? [];\n        this.serverless.service.provider.iamRoleStatements.push(...statements);\n    }\n\n    private async eject() {\n        log(\"Ejecting from Lift to CloudFormation\");\n        await this.serverless.pluginManager.spawn(\"package\");\n        const legacyProvider = this.serverless.getProvider(\"aws\");\n        const compiledTemplateFileName = legacyProvider.naming.getCompiledTemplateFileName();\n        const compiledTemplateFilePath = path.join(this.serverless.serviceDir, \".serverless\", compiledTemplateFileName);\n        const cfTemplate = readFileSync(compiledTemplateFilePath);\n        const formattedYaml = dump(JSON.parse(cfTemplate.toString()));\n        console.log(formattedYaml);\n        log(\"You can also find that CloudFormation template in the following file:\");\n        log(compiledTemplateFilePath);\n    }\n}\n\nmodule.exports = LiftPlugin;\n"],
  "mappings": "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",
  "names": []
}
